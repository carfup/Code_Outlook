/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import type { ApprovalEmailSubscription } from '../models/Office365OutlookModel';
import type { AutomaticRepliesSettingClient } from '../models/Office365OutlookModel';
import type { BatchOperationResult } from '../models/Office365OutlookModel';
import type { BatchResponse_ClientReceiveMessage } from '../models/Office365OutlookModel';
import type { BatchResponse_GraphClientReceiveMessage } from '../models/Office365OutlookModel';
import type { BatchResponse_SensitivityLabel } from '../models/Office365OutlookModel';
import type { CalendarEventBackend } from '../models/Office365OutlookModel';
import type { CalendarEventClient } from '../models/Office365OutlookModel';
import type { CalendarEventClientReceiveStringEnums } from '../models/Office365OutlookModel';
import type { CalendarEventHtmlClient } from '../models/Office365OutlookModel';
import type { CalendarEventList } from '../models/Office365OutlookModel';
import type { CalendarEventListClientReceive } from '../models/Office365OutlookModel';
import type { CalendarEventListWithActionType } from '../models/Office365OutlookModel';
import type { ClientDraftHtmlMessage } from '../models/Office365OutlookModel';
import type { ClientReceiveMessage } from '../models/Office365OutlookModel';
import type { ClientReceiveMessageStringEnums } from '../models/Office365OutlookModel';
import type { ClientSendHtmlMessage } from '../models/Office365OutlookModel';
import type { ClientSendMessage } from '../models/Office365OutlookModel';
import type { ClientSubscription } from '../models/Office365OutlookModel';
import type { Contact } from '../models/Office365OutlookModel';
import type { ContactResponse } from '../models/Office365OutlookModel';
import type { ContactResponse_V2 } from '../models/Office365OutlookModel';
import type { Contact_V2 } from '../models/Office365OutlookModel';
import type { DataSetsList } from '../models/Office365OutlookModel';
import type { DataSetsMetadata } from '../models/Office365OutlookModel';
import type { DirectForwardMessage } from '../models/Office365OutlookModel';
import type { EntityListResponse_CalendarEventBackend } from '../models/Office365OutlookModel';
import type { EntityListResponse_CalendarEventClientReceiveStringEnums } from '../models/Office365OutlookModel';
import type { EntityListResponse_ContactResponse } from '../models/Office365OutlookModel';
import type { EntityListResponse_ContactResponse_V2 } from '../models/Office365OutlookModel';
import type { EntityListResponse_FilePickerFile } from '../models/Office365OutlookModel';
import type { EntityListResponse_GraphCalendarEventClientReceive } from '../models/Office365OutlookModel';
import type { EntityListResponse_GraphContactFolder } from '../models/Office365OutlookModel';
import type { EntityListResponse_Table } from '../models/Office365OutlookModel';
import type { GraphCalendarEventClient } from '../models/Office365OutlookModel';
import type { GraphCalendarEventClientReceive } from '../models/Office365OutlookModel';
import type { GraphCalendarEventListClientReceive } from '../models/Office365OutlookModel';
import type { GraphCalendarEventListWithActionType } from '../models/Office365OutlookModel';
import type { GraphClientReceiveMessage } from '../models/Office365OutlookModel';
import type { GraphOutlookCategory } from '../models/Office365OutlookModel';
import type { IOperationResult } from '@microsoft/power-apps/data';
import type { MCPQueryRequest } from '../models/Office365OutlookModel';
import type { MCPQueryResponse } from '../models/Office365OutlookModel';
import type { MailTipsClientReceive } from '../models/Office365OutlookModel';
import type { MailTipsClientReceive_V2 } from '../models/Office365OutlookModel';
import type { ObjectWithoutType } from '../models/Office365OutlookModel';
import type { OptionsEmailSubscription } from '../models/Office365OutlookModel';
import type { OutlookReceiveMessage } from '../models/Office365OutlookModel';
import type { PaginatedListResponse_CalendarEventClientReceiveStringEnums } from '../models/Office365OutlookModel';
import type { ReplyHtmlMessage } from '../models/Office365OutlookModel';
import type { ReplyMessage } from '../models/Office365OutlookModel';
import type { ResponseToEventInvite } from '../models/Office365OutlookModel';
import type { SharedMailboxClientSendHtmlMessage } from '../models/Office365OutlookModel';
import type { SharedMailboxClientSendMessage } from '../models/Office365OutlookModel';
import type { SubscriptionPayload_OutlookReceiveMessage } from '../models/Office365OutlookModel';
import type { SubscriptionPayload_SubscriptionEvent } from '../models/Office365OutlookModel';
import type { TableMetadata } from '../models/Office365OutlookModel';
import type { TriggerBatchResponse_ClientReceiveMessage } from '../models/Office365OutlookModel';
import type { TriggerBatchResponse_GraphClientReceiveMessage } from '../models/Office365OutlookModel';
import { dataSourcesInfo } from '../../../.power/schemas/appschemas/dataSourcesInfo';
import { getClient } from '@microsoft/power-apps/data';

export class Office365OutlookService {
  private static readonly dataSourceName = 'office365';

  private static readonly client = getClient(dataSourcesInfo);

  /**
   * Get calendar metadata
   * This operation gets metadata for a calendar.
   */
  public static async CalendarGetTable(table: string): Promise<IOperationResult<TableMetadata>> {
    const params: { table: string } = { table };
    const result = await Office365OutlookService.client.executeAsync<{ table: string }, TableMetadata>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetTable',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get folder metadata
   * This operation gets metadata for a contacts folder.
   */
  public static async ContactGetTable(table: string): Promise<IOperationResult<TableMetadata>> {
    const params: { table: string } = { table };
    const result = await Office365OutlookService.client.executeAsync<{ table: string }, TableMetadata>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactGetTable',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an upcoming event is starting soon
   * This operation triggers a flow when an upcoming calendar event is starting.
   */
  public static async OnUpcomingEvents(table: string, lookAheadTimeInMinutes?: number): Promise<IOperationResult<CalendarEventList>> {
    const params: { table: string, lookAheadTimeInMinutes?: number } = { table, lookAheadTimeInMinutes };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, lookAheadTimeInMinutes?: number }, CalendarEventList>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnUpcomingEvents',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an upcoming event is starting soon (V2)
   * This operation triggers a flow when an upcoming calendar event is starting.
   */
  public static async OnUpcomingEventsV2(table: string, lookAheadTimeInMinutes?: number): Promise<IOperationResult<CalendarEventListClientReceive>> {
    const params: { table: string, lookAheadTimeInMinutes?: number } = { table, lookAheadTimeInMinutes };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, lookAheadTimeInMinutes?: number }, CalendarEventListClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnUpcomingEventsV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an upcoming event is starting soon (V3)
   * This operation triggers a flow when an upcoming calendar event is starting.
   */
  public static async OnUpcomingEventsV3(table: string, lookAheadTimeInMinutes?: number): Promise<IOperationResult<GraphCalendarEventListClientReceive>> {
    const params: { table: string, lookAheadTimeInMinutes?: number } = { table, lookAheadTimeInMinutes };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, lookAheadTimeInMinutes?: number }, GraphCalendarEventListClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnUpcomingEventsV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get calendar view of events
   * Get calendar view of events.
   */
  public static async GetEventsCalendarView(calendarId: string, startDateTimeOffset: string, endDateTimeOffset: string): Promise<IOperationResult<PaginatedListResponse_CalendarEventClientReceiveStringEnums>> {
    const params: { calendarId: string, startDateTimeOffset: string, endDateTimeOffset: string } = { calendarId, startDateTimeOffset, endDateTimeOffset };
    const result = await Office365OutlookService.client.executeAsync<{ calendarId: string, startDateTimeOffset: string, endDateTimeOffset: string }, PaginatedListResponse_CalendarEventClientReceiveStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetEventsCalendarView',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an event is added, updated or deleted in a calendar - Outlook subscription
   * Create an Outlook webhook subscription for the trigger when an event is added, updated or deleted in a calendar.
   */
  public static async CreateOnChangedEventPokeSubscription(subscription: ClientSubscription, table: string, incomingDays?: number, pastDays?: number): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, table: string, incomingDays?: number, pastDays?: number } = { subscription, table, incomingDays, pastDays };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, table: string, incomingDays?: number, pastDays?: number }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateOnChangedEventPokeSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an event is added, updated or deleted in a calendar - Graph subscription
   * Create a Graph webhook subscription for the trigger when an event is added, updated or deleted in a calendar.
   */
  public static async CreateGraphOnChangedEventPokeSubscription(subscription: ClientSubscription, table: string, incomingDays?: number, pastDays?: number): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, table: string, incomingDays?: number, pastDays?: number } = { subscription, table, incomingDays, pastDays };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, table: string, incomingDays?: number, pastDays?: number }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateGraphOnChangedEventPokeSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete event subscription
   * This operation deletes an event subscription.
   */
  public static async DeleteEventSubscription(id: string, options: string): Promise<IOperationResult<void>> {
    const params: { id: string, options: string } = { id, options };
    const result = await Office365OutlookService.client.executeAsync<{ id: string, options: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'DeleteEventSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update web hook
   * Update web hook with renew interval.
   */
  public static async RenewEventSubscription(id: string, options: string, subscription: ClientSubscription): Promise<IOperationResult<void>> {
    const params: { id: string, options: string, subscription: ClientSubscription } = { id, options, subscription };
    const result = await Office365OutlookService.client.executeAsync<{ id: string, options: string, subscription: ClientSubscription }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'RenewEventSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When the file picker is opened for the first time
   * When the file picker is opened for the first time.
   */
  public static async OnFilePickerOpen(operation: string, top?: number, skip?: number, mailboxAddress?: string): Promise<IOperationResult<EntityListResponse_FilePickerFile>> {
    const params: { operation: string, top?: number, skip?: number, mailboxAddress?: string } = { operation, top, skip, mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ operation: string, top?: number, skip?: number, mailboxAddress?: string }, EntityListResponse_FilePickerFile>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnFilePickerOpen',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When the file picker is open and being browsed
   * When the file picker is open and being browsed.
   */
  public static async OnFilePickerBrowse(operation: string, id: string, top?: number, skip?: number, mailboxAddress?: string): Promise<IOperationResult<EntityListResponse_FilePickerFile>> {
    const params: { operation: string, id: string, top?: number, skip?: number, mailboxAddress?: string } = { operation, id, top, skip, mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ operation: string, id: string, top?: number, skip?: number, mailboxAddress?: string }, EntityListResponse_FilePickerFile>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnFilePickerBrowse',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get emails
   * This operation gets emails from a folder.
   */
  public static async GetEmails(folderPath?: string, fetchOnlyUnread?: boolean, includeAttachments?: boolean, searchQuery?: string, top?: number, skip?: number): Promise<IOperationResult<ClientReceiveMessageStringEnums[]>> {
    const params: { folderPath?: string, fetchOnlyUnread?: boolean, includeAttachments?: boolean, searchQuery?: string, top?: number, skip?: number } = { folderPath, fetchOnlyUnread, includeAttachments, searchQuery, top, skip };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, fetchOnlyUnread?: boolean, includeAttachments?: boolean, searchQuery?: string, top?: number, skip?: number }, ClientReceiveMessageStringEnums[]>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetEmails',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Send an email
   * This operation sends an email message.
   */
  public static async SendEmail(emailMessage: ClientSendMessage): Promise<IOperationResult<void>> {
    const params: { emailMessage: ClientSendMessage } = { emailMessage };
    const result = await Office365OutlookService.client.executeAsync<{ emailMessage: ClientSendMessage }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SendEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get Outlook category names
   * This operation gets Outlook category display names.
   */
  public static async GetOutlookCategoryNames(): Promise<IOperationResult<GraphOutlookCategory[]>> {
    const result = await Office365OutlookService.client.executeAsync<void, GraphOutlookCategory[]>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetOutlookCategoryNames',
        },
      });
    return result;
  }

  /**
   * Draft an email message
   * This operation drafts an email message.
   */
  public static async DraftEmail(draftMessage: ClientDraftHtmlMessage, messageId?: string, draftType?: string, comment?: string): Promise<IOperationResult<OutlookReceiveMessage>> {
    const params: { draftMessage: ClientDraftHtmlMessage, messageId?: string, draftType?: string, comment?: string } = { draftMessage, messageId, draftType, comment };
    const result = await Office365OutlookService.client.executeAsync<{ draftMessage: ClientDraftHtmlMessage, messageId?: string, draftType?: string, comment?: string }, OutlookReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'DraftEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Updates an email Draft message
   * This operation updates an an email Draft message.
   */
  public static async UpdateDraftEmail(draftMessage: ClientDraftHtmlMessage, messageId: string): Promise<IOperationResult<void>> {
    const params: { draftMessage: ClientDraftHtmlMessage, messageId: string } = { draftMessage, messageId };
    const result = await Office365OutlookService.client.executeAsync<{ draftMessage: ClientDraftHtmlMessage, messageId: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'UpdateDraftEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Send a Draft message
   * This operation sends a Draft message.
   */
  public static async SendDraftEmail(messageId: string): Promise<IOperationResult<void>> {
    const params: { messageId: string } = { messageId };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SendDraftEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Assigns an Outlook category
   * This operation assigns an Outlook category to an email.
   */
  public static async AssignCategory(messageId: string, category: string): Promise<IOperationResult<void>> {
    const params: { messageId: string, category: string } = { messageId, category };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, category: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'AssignCategory',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Assign a category to multiple emails
   * This operation assigns an Outlook category to multiple emails.
   */
  public static async AssignCategoryBulk(messageIds: unknown, categoryName: string): Promise<IOperationResult<BatchOperationResult>> {
    const params: { messageIds: unknown, categoryName: string } = { messageIds, categoryName };
    const result = await Office365OutlookService.client.executeAsync<{ messageIds: unknown, categoryName: string }, BatchOperationResult>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'AssignCategoryBulk',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get emails (V2)
   * This operation gets emails from a folder.
   */
  public static async GetEmailsV2(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, subjectFilter?: string, fetchOnlyUnread?: boolean, fetchOnlyFlagged?: boolean, mailboxAddress?: string, includeAttachments?: boolean, searchQuery?: string, top?: number): Promise<IOperationResult<BatchResponse_ClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, subjectFilter?: string, fetchOnlyUnread?: boolean, fetchOnlyFlagged?: boolean, mailboxAddress?: string, includeAttachments?: boolean, searchQuery?: string, top?: number } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, subjectFilter, fetchOnlyUnread, fetchOnlyFlagged, mailboxAddress, includeAttachments, searchQuery, top };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, subjectFilter?: string, fetchOnlyUnread?: boolean, fetchOnlyFlagged?: boolean, mailboxAddress?: string, includeAttachments?: boolean, searchQuery?: string, top?: number }, BatchResponse_ClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetEmailsV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Send an email (V2)
   * This operation sends an email message.
   */
  public static async SendEmailV2(emailMessage: ClientSendHtmlMessage): Promise<IOperationResult<void>> {
    const params: { emailMessage: ClientSendHtmlMessage } = { emailMessage };
    const result = await Office365OutlookService.client.executeAsync<{ emailMessage: ClientSendHtmlMessage }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SendEmailV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get email
   * This operation gets an email by id.
   */
  public static async GetEmail(messageId: string, mailboxAddress?: string, includeAttachments?: boolean, internetMessageId?: string): Promise<IOperationResult<ClientReceiveMessage>> {
    const params: { messageId: string, mailboxAddress?: string, includeAttachments?: boolean, internetMessageId?: string } = { messageId, mailboxAddress, includeAttachments, internetMessageId };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, mailboxAddress?: string, includeAttachments?: boolean, internetMessageId?: string }, ClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete email
   * This operation deletes an email by id.
   */
  public static async DeleteEmail(messageId: string): Promise<IOperationResult<void>> {
    const params: { messageId: string } = { messageId };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'DeleteEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get email (V2)
   * This operation gets an email by id.
   */
  public static async GetEmailV2(messageId: string, mailboxAddress?: string, includeAttachments?: boolean, internetMessageId?: string, extractSensitivityLabel?: boolean, fetchSensitivityLabelMetadata?: boolean): Promise<IOperationResult<GraphClientReceiveMessage>> {
    const params: { messageId: string, mailboxAddress?: string, includeAttachments?: boolean, internetMessageId?: string, extractSensitivityLabel?: boolean, fetchSensitivityLabelMetadata?: boolean } = { messageId, mailboxAddress, includeAttachments, internetMessageId, extractSensitivityLabel, fetchSensitivityLabelMetadata };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, mailboxAddress?: string, includeAttachments?: boolean, internetMessageId?: string, extractSensitivityLabel?: boolean, fetchSensitivityLabelMetadata?: boolean }, GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetEmailV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get emails (V3)
   * This operation gets emails from a folder via graph apis. Please note that filtering related to these fields: To, Cc, To Or Cc, From, Importance, Fetch Only With Attachments, Subject Filter, is performed using first 250 items in a given mail folder. To avoid that limitation you can use 'Search Query' field.
   */
  public static async GetEmailsV3(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, subjectFilter?: string, fetchOnlyUnread?: boolean, fetchOnlyFlagged?: boolean, mailboxAddress?: string, includeAttachments?: boolean, searchQuery?: string, top?: number): Promise<IOperationResult<BatchResponse_GraphClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, subjectFilter?: string, fetchOnlyUnread?: boolean, fetchOnlyFlagged?: boolean, mailboxAddress?: string, includeAttachments?: boolean, searchQuery?: string, top?: number } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, subjectFilter, fetchOnlyUnread, fetchOnlyFlagged, mailboxAddress, includeAttachments, searchQuery, top };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, subjectFilter?: string, fetchOnlyUnread?: boolean, fetchOnlyFlagged?: boolean, mailboxAddress?: string, includeAttachments?: boolean, searchQuery?: string, top?: number }, BatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetEmailsV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Move email
   * This operation moves an email to the specified folder within the same mailbox.
   */
  public static async Move(messageId: string, folderPath: string): Promise<IOperationResult<ClientReceiveMessageStringEnums>> {
    const params: { messageId: string, folderPath: string } = { messageId, folderPath };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, folderPath: string }, ClientReceiveMessageStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'Move',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Move email (V2)
   * This operation moves an email to the specified folder within the same mailbox.
   */
  public static async MoveV2(messageId: string, folderPath: string, mailboxAddress?: string): Promise<IOperationResult<GraphClientReceiveMessage>> {
    const params: { messageId: string, folderPath: string, mailboxAddress?: string } = { messageId, folderPath, mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, folderPath: string, mailboxAddress?: string }, GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'MoveV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Flag email
   * This operation flags an email.
   */
  public static async Flag(messageId: string): Promise<IOperationResult<void>> {
    const params: { messageId: string } = { messageId };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'Flag',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Mark as read
   * This operation marks an email as having been read.
   */
  public static async MarkAsRead(messageId: string): Promise<IOperationResult<void>> {
    const params: { messageId: string } = { messageId };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'MarkAsRead',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Reply to email
   * This operation replies to an email.
   */
  public static async ReplyTo(messageId: string, comment: string, replyAll?: boolean): Promise<IOperationResult<void>> {
    const params: { messageId: string, comment: string, replyAll?: boolean } = { messageId, comment, replyAll };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, comment: string, replyAll?: boolean }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReplyTo',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Reply to email (V2)
   * This operation replies to an email.
   */
  public static async ReplyToV2(messageId: string, replyParameters: ReplyMessage, mailboxAddress?: string): Promise<IOperationResult<void>> {
    const params: { messageId: string, replyParameters: ReplyMessage, mailboxAddress?: string } = { messageId, replyParameters, mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, replyParameters: ReplyMessage, mailboxAddress?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReplyToV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Reply to email (V3)
   * This operation replies to an email.
   */
  public static async ReplyToV3(messageId: string, replyParameters: ReplyHtmlMessage, mailboxAddress?: string): Promise<IOperationResult<void>> {
    const params: { messageId: string, replyParameters: ReplyHtmlMessage, mailboxAddress?: string } = { messageId, replyParameters, mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, replyParameters: ReplyHtmlMessage, mailboxAddress?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReplyToV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get attachment
   * This operation gets an email attachment by id.
   */
  public static async GetAttachment(messageId: string, attachmentId: string): Promise<IOperationResult<string>> {
    const params: { messageId: string, attachmentId: string } = { messageId, attachmentId };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, attachmentId: string }, string>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetAttachment',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new email arrives
   * This operation triggers a flow when a new email arrives. It will skip any email that has a total message size greater than the limit put by your Exchange Admin or 50 MB, whichever is less. It may also skip protected emails and emails with invalid body or attachments.
   */
  public static async OnNewEmail(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string): Promise<IOperationResult<TriggerBatchResponse_ClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string }, TriggerBatchResponse_ClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnNewEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new email arrives (V2)
   * This operation triggers a flow when a new email arrives. It will skip any email that has a total message size greater than the limit put by your Exchange Admin or 50 MB, whichever is less. It may also skip protected emails and emails with invalid body or attachments.
   */
  public static async OnNewEmailV2(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string): Promise<IOperationResult<TriggerBatchResponse_GraphClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string }, TriggerBatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnNewEmailV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new email arrives (V3)
   * This operation triggers a flow when a new email arrives. It will skip any email that has a total message size greater than the limit put by your Exchange Admin or 50 MB, whichever is less. It may also skip protected emails and emails with invalid body or attachments.
   */
  public static async OnNewEmailV3(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string): Promise<IOperationResult<TriggerBatchResponse_GraphClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string }, TriggerBatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnNewEmailV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an email is flagged
   * This operation triggers a flow when an email is flagged.
   */
  public static async OnFlaggedEmail(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string): Promise<IOperationResult<TriggerBatchResponse_ClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string }, TriggerBatchResponse_ClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnFlaggedEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an email is flagged (V2)
   * This operation triggers a flow when an email is flagged.
   */
  public static async OnFlaggedEmailV2(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string): Promise<IOperationResult<TriggerBatchResponse_GraphClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string }, TriggerBatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnFlaggedEmailV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an email is flagged (V3)
   * This operation triggers a flow when an email is flagged.
   */
  public static async OnFlaggedEmailV3(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string): Promise<IOperationResult<TriggerBatchResponse_GraphClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string }, TriggerBatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnFlaggedEmailV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an email is flagged (V4)
   * This operation triggers a flow when an email is flagged.
   */
  public static async OnFlaggedEmailV4(folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string): Promise<IOperationResult<TriggerBatchResponse_GraphClientReceiveMessage>> {
    const params: { folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string } = { folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter };
    const result = await Office365OutlookService.client.executeAsync<{ folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string }, TriggerBatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnFlaggedEmailV4',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new email mentioning me arrives
   * This operation triggers a flow when a new email mentioning me arrives. It will skip any email that has a total message size greater than the limit put by your Exchange Admin or 50 MB, whichever is less. It may also skip protected emails and emails with invalid body or attachments.
   */
  public static async OnNewMentionMeEmail(messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string): Promise<IOperationResult<TriggerBatchResponse_ClientReceiveMessage>> {
    const params: { messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string } = { messageIdToFireOnFirstTriggerRun, folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter };
    const result = await Office365OutlookService.client.executeAsync<{ messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string }, TriggerBatchResponse_ClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnNewMentionMeEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new email mentioning me arrives (V2)
   * This operation triggers a flow when a new email mentioning me arrives. It will skip any email that has a total message size greater than the limit put by your Exchange Admin or 50 MB, whichever is less. It may also skip protected emails and emails with invalid body or attachments.
   */
  public static async OnNewMentionMeEmailV2(messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string): Promise<IOperationResult<TriggerBatchResponse_GraphClientReceiveMessage>> {
    const params: { messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string } = { messageIdToFireOnFirstTriggerRun, folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter };
    const result = await Office365OutlookService.client.executeAsync<{ messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string }, TriggerBatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnNewMentionMeEmailV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new email mentioning me arrives (V3)
   * This operation triggers a flow when a new email mentioning me arrives. It will skip any email that has a total message size greater than the limit put by your Exchange Admin or 50 MB, whichever is less. It may also skip protected emails and emails with invalid body or attachments.
   */
  public static async OnNewMentionMeEmailV3(messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string): Promise<IOperationResult<TriggerBatchResponse_GraphClientReceiveMessage>> {
    const params: { messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string } = { messageIdToFireOnFirstTriggerRun, folderPath, to, cc, toOrCc, from, importance, fetchOnlyWithAttachment, includeAttachments, subjectFilter };
    const result = await Office365OutlookService.client.executeAsync<{ messageIdToFireOnFirstTriggerRun?: string, folderPath?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, fetchOnlyWithAttachment?: boolean, includeAttachments?: boolean, subjectFilter?: string }, TriggerBatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'OnNewMentionMeEmailV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Set up automatic replies
   * Set the automatic replies setting for your mailbox.
   */
  public static async SetAutomaticRepliesSetting(clientSetting: AutomaticRepliesSettingClient): Promise<IOperationResult<void>> {
    const params: { clientSetting: AutomaticRepliesSettingClient } = { clientSetting };
    const result = await Office365OutlookService.client.executeAsync<{ clientSetting: AutomaticRepliesSettingClient }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SetAutomaticRepliesSetting',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get mail tips for a mailbox
   * Get mail tips for a mailbox such as automatic replies / OOF message or if the mailbox is full.
   */
  public static async GetMailTips(mailboxAddress: string): Promise<IOperationResult<MailTipsClientReceive>> {
    const params: { mailboxAddress: string } = { mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ mailboxAddress: string }, MailTipsClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetMailTips',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get sensitivity labels
   * Get a collection of information protection labels available to the user.
   */
  public static async GetSensitivityLabels(): Promise<IOperationResult<BatchResponse_SensitivityLabel>> {
    const result = await Office365OutlookService.client.executeAsync<void, BatchResponse_SensitivityLabel>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetSensitivityLabels',
        },
      });
    return result;
  }

  /**
   * When a new email arrives (webhook)
   * This operation triggers a flow when a new email arrives.
   */
  public static async CreateOnNewEmailSubscription(subscription: ClientSubscription, folderPath?: string, importance?: string, hasAttachment?: string): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, folderPath?: string, importance?: string, hasAttachment?: string } = { subscription, folderPath, importance, hasAttachment };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, folderPath?: string, importance?: string, hasAttachment?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateOnNewEmailSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create a webhook subscription for the trigger when a new email arrives
   * Create a webhook subscription for the trigger when a new email arrives.
   */
  public static async CreateOnNewEmailPokeSubscription(subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean } = { subscription, folderPath, importance, fetchOnlyWithAttachment };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateOnNewEmailPokeSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create a Graph webhook subscription for the trigger when a new email arrives
   * Create a Graph webhook subscription for the trigger when a new email arrives.
   */
  public static async CreateGraphOnNewEmailPokeSubscription(subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean } = { subscription, folderPath, importance, fetchOnlyWithAttachment };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateGraphOnNewEmailPokeSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new mentioning me email arrives - Outlook subscription
   * Create an Outlook webhook subscription for the trigger when a new mentioning me email arrives.
   */
  public static async CreateOnNewMentionMeEmailPokeSubscription(subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean } = { subscription, folderPath, importance, fetchOnlyWithAttachment };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateOnNewMentionMeEmailPokeSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new mentioning me email arrives - Graph subscription
   * Create a Graph webhook subscription for the trigger when a new mentioning me email arrives.
   */
  public static async CreateGraphOnNewMentionMeEmailPokeSubscription(subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean } = { subscription, folderPath, importance, fetchOnlyWithAttachment };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateGraphOnNewMentionMeEmailPokeSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create an Outlook webhook subscription for the trigger when an email is flagged
   * Create an Outlook webhook subscription for the trigger when an email is flagged.
   */
  public static async CreateOnFlaggedEmailPokeSubscription(subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean } = { subscription, folderPath, importance, fetchOnlyWithAttachment };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateOnFlaggedEmailPokeSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create a Graph webhook subscription for the trigger when an email is flagged
   * Create a Graph webhook subscription for the trigger when an email is flagged.
   */
  public static async CreateGraphOnFlaggedEmailPokeSubscription(subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean): Promise<IOperationResult<void>> {
    const params: { subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean } = { subscription, folderPath, importance, fetchOnlyWithAttachment };
    const result = await Office365OutlookService.client.executeAsync<{ subscription: ClientSubscription, folderPath?: string, importance?: string, fetchOnlyWithAttachment?: boolean }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CreateGraphOnFlaggedEmailPokeSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete mail subscription
   * This operation deletes a mail subscription.
   */
  public static async DeleteOnNewEmailSubscription(id: string, options: string): Promise<IOperationResult<void>> {
    const params: { id: string, options: string } = { id, options };
    const result = await Office365OutlookService.client.executeAsync<{ id: string, options: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'DeleteOnNewEmailSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update web hook
   * Update web hook with renew interval.
   */
  public static async RenewOnNewEmailSubscription(id: string, options: string, subscription: ClientSubscription): Promise<IOperationResult<void>> {
    const params: { id: string, options: string, subscription: ClientSubscription } = { id, options, subscription };
    const result = await Office365OutlookService.client.executeAsync<{ id: string, options: string, subscription: ClientSubscription }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'RenewOnNewEmailSubscription',
          parameters: params
        },
      });
    return result;
  }

  public static async GetDataSetsMetadata(): Promise<IOperationResult<DataSetsMetadata>> {
    const result = await Office365OutlookService.client.executeAsync<void, DataSetsMetadata>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetDataSetsMetadata',
        },
      });
    return result;
  }

  /**
   * Send email with options
   * This operation sends an email with multiple options and waits for the recipient to respond back with one of the options. Please refer to the following link regarding the support of actionable messages in different mail clients: https://docs.microsoft.com/outlook/actionable-messages/#outlook-version-requirements-for-actionable-messages.
   */
  public static async SendMailWithOptions(optionsEmailSubscription: OptionsEmailSubscription): Promise<IOperationResult<void>> {
    const params: { optionsEmailSubscription: OptionsEmailSubscription } = { optionsEmailSubscription };
    const result = await Office365OutlookService.client.executeAsync<{ optionsEmailSubscription: OptionsEmailSubscription }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SendMailWithOptions',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Send approval email
   * This operation sends an approval email and waits for a response from the recipient. Please refer to the following link regarding the support of actionable messages in different mail clients: https://docs.microsoft.com/outlook/actionable-messages/#outlook-version-requirements-for-actionable-messages.
   */
  public static async SendApprovalMail(approvalEmailSubscription: ApprovalEmailSubscription): Promise<IOperationResult<void>> {
    const params: { approvalEmailSubscription: ApprovalEmailSubscription } = { approvalEmailSubscription };
    const result = await Office365OutlookService.client.executeAsync<{ approvalEmailSubscription: ApprovalEmailSubscription }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SendApprovalMail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete approval email subscription
   * This operation deletes a subscription of approval email.
   */
  public static async DeleteApprovalMailSubscription(id: string): Promise<IOperationResult<void>> {
    const params: { id: string } = { id };
    const result = await Office365OutlookService.client.executeAsync<{ id: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'DeleteApprovalMailSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete options email subscription
   * This operation deletes a subscription of options email.
   */
  public static async DeleteOptionsMailSubscription(id: string): Promise<IOperationResult<void>> {
    const params: { id: string } = { id };
    const result = await Office365OutlookService.client.executeAsync<{ id: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'DeleteOptionsMailSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Send an email from a shared mailbox
   * This operation sends an email from a shared mailbox. Your account should have permission to access the mailbox for this operation to succeed.
   */
  public static async SharedMailboxSendEmail(emailMessage: SharedMailboxClientSendMessage): Promise<IOperationResult<void>> {
    const params: { emailMessage: SharedMailboxClientSendMessage } = { emailMessage };
    const result = await Office365OutlookService.client.executeAsync<{ emailMessage: SharedMailboxClientSendMessage }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SharedMailboxSendEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Send an email from a shared mailbox (V2)
   * This operation sends an email from a shared mailbox. Your account should have permission to access the mailbox for this operation to succeed.
   */
  public static async SharedMailboxSendEmailV2(emailMessage: SharedMailboxClientSendHtmlMessage): Promise<IOperationResult<void>> {
    const params: { emailMessage: SharedMailboxClientSendHtmlMessage } = { emailMessage };
    const result = await Office365OutlookService.client.executeAsync<{ emailMessage: SharedMailboxClientSendHtmlMessage }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SharedMailboxSendEmailV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new email arrives in a shared mailbox
   * This operation triggers a flow when a new email arrives in a shared mailbox. Your account should have permission to access the mailbox for this operation to succeed. It will skip any email that has a total message size greater than the limit put by your Exchange Admin or 50 MB, whichever is less. It may also skip protected emails and emails with invalid body or attachments.
   */
  public static async SharedMailboxOnNewEmail(mailboxAddress: string, folderId?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, hasAttachments?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string): Promise<IOperationResult<TriggerBatchResponse_ClientReceiveMessage>> {
    const params: { mailboxAddress: string, folderId?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, hasAttachments?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string } = { mailboxAddress, folderId, to, cc, toOrCc, from, importance, hasAttachments, includeAttachments, subjectFilter, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ mailboxAddress: string, folderId?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, hasAttachments?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string }, TriggerBatchResponse_ClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SharedMailboxOnNewEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new email arrives in a shared mailbox (V2)
   * This operation triggers a flow when a new email arrives in a shared mailbox. Your account should have permission to access the mailbox for this operation to succeed. It will skip any email that has a total message size greater than the limit put by your Exchange Admin or 50 MB, whichever is less. It may also skip protected emails and emails with invalid body or attachments.
   */
  public static async SharedMailboxOnNewEmailV2(mailboxAddress: string, folderId?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, hasAttachments?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string): Promise<IOperationResult<TriggerBatchResponse_GraphClientReceiveMessage>> {
    const params: { mailboxAddress: string, folderId?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, hasAttachments?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string } = { mailboxAddress, folderId, to, cc, toOrCc, from, importance, hasAttachments, includeAttachments, subjectFilter, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ mailboxAddress: string, folderId?: string, to?: string, cc?: string, toOrCc?: string, from?: string, importance?: string, hasAttachments?: boolean, includeAttachments?: boolean, subjectFilter?: string, x_ms_operation_context?: string }, TriggerBatchResponse_GraphClientReceiveMessage>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SharedMailboxOnNewEmailV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Tests the connection
   * Tests the connection.
   */
  public static async TestConnection(): Promise<IOperationResult<void>> {
    const result = await Office365OutlookService.client.executeAsync<void, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'TestConnection',
        },
      });
    return result;
  }

  /**
   * Get calendars
   * This operation lists available calendars.
   */
  public static async CalendarGetTables(): Promise<IOperationResult<EntityListResponse_Table>> {
    const result = await Office365OutlookService.client.executeAsync<void, EntityListResponse_Table>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetTables',
        },
      });
    return result;
  }

  /**
   * Get events (V1)
   * This operation gets events from a calendar. (V1)
   */
  public static async CalendarGetItems(table: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<EntityListResponse_CalendarEventBackend>> {
    const params: { table: string, $orderby?: string, $top?: number, $skip?: number } = { table, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $orderby?: string, $top?: number, $skip?: number }, EntityListResponse_CalendarEventBackend>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create event (V1)
   * This operation creates a new event in a calendar. (V1)
   */
  public static async CalendarPostItem(table: string, item: CalendarEventBackend): Promise<IOperationResult<CalendarEventBackend>> {
    const params: { table: string, item: CalendarEventBackend } = { table, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, item: CalendarEventBackend }, CalendarEventBackend>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarPostItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get event (V1)
   * This operation gets a specific event from a calendar. (V1)
   */
  public static async CalendarGetItem(table: string, id: string): Promise<IOperationResult<CalendarEventBackend>> {
    const params: { table: string, id: string } = { table, id };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string }, CalendarEventBackend>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete event
   * This operation deletes an event in a calendar.
   */
  public static async CalendarDeleteItem(table: string, id: string): Promise<IOperationResult<void>> {
    const params: { table: string, id: string } = { table, id };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarDeleteItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update event (V1)
   * This operation updates an event in a calendar. (V1)
   */
  public static async CalendarPatchItem(table: string, id: string, item: CalendarEventBackend): Promise<IOperationResult<CalendarEventBackend>> {
    const params: { table: string, id: string, item: CalendarEventBackend } = { table, id, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string, item: CalendarEventBackend }, CalendarEventBackend>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarPatchItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get events (V3)
   * This operation gets events from a calendar. (V3)
   */
  public static async V3CalendarGetItems(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<CalendarEventListClientReceive>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, CalendarEventListClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V3CalendarGetItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create event (V3)
   * This operation creates a new event in a calendar.
   */
  public static async V3CalendarPostItem(table: string, item: CalendarEventHtmlClient): Promise<IOperationResult<CalendarEventClientReceiveStringEnums>> {
    const params: { table: string, item: CalendarEventHtmlClient } = { table, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, item: CalendarEventHtmlClient }, CalendarEventClientReceiveStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V3CalendarPostItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get events (V4)
   * This operation gets events from a calendar using Graph API. (V4)
   */
  public static async V4CalendarGetItems(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<GraphCalendarEventListClientReceive>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, GraphCalendarEventListClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V4CalendarGetItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create event (V4)
   * This operation creates a new event in a calendar.
   */
  public static async V4CalendarPostItem(table: string, item: GraphCalendarEventClient): Promise<IOperationResult<GraphCalendarEventClientReceive>> {
    const params: { table: string, item: GraphCalendarEventClient } = { table, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, item: GraphCalendarEventClient }, GraphCalendarEventClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V4CalendarPostItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get events (V2)
   * This operation gets events from a calendar. (V2)
   */
  public static async V2CalendarGetItems(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<EntityListResponse_CalendarEventClientReceiveStringEnums>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, EntityListResponse_CalendarEventClientReceiveStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V2CalendarGetItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create event (V2)
   * This operation creates a new event in a calendar. (V2)
   */
  public static async V2CalendarPostItem(table: string, item: CalendarEventClient): Promise<IOperationResult<CalendarEventClientReceiveStringEnums>> {
    const params: { table: string, item: CalendarEventClient } = { table, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, item: CalendarEventClient }, CalendarEventClientReceiveStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V2CalendarPostItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get calendar view of events (V2)
   * This operation gets all events (including instances of recurrences) in a calendar. Recurrence property is null in this case.
   */
  public static async GetEventsCalendarViewV2(calendarId: string, startDateTimeOffset: string, endDateTimeOffset: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, search?: string): Promise<IOperationResult<EntityListResponse_CalendarEventClientReceiveStringEnums>> {
    const params: { calendarId: string, startDateTimeOffset: string, endDateTimeOffset: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, search?: string } = { calendarId, startDateTimeOffset, endDateTimeOffset, $filter, $orderby, $top, $skip, search };
    const result = await Office365OutlookService.client.executeAsync<{ calendarId: string, startDateTimeOffset: string, endDateTimeOffset: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, search?: string }, EntityListResponse_CalendarEventClientReceiveStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetEventsCalendarViewV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get calendar view of events (V3)
   * This operation gets all events (including instances of recurrences) in a calendar using Graph API. Recurrence property is null in this case.
   */
  public static async GetEventsCalendarViewV3(calendarId: string, startDateTimeUtc: string, endDateTimeUtc: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, search?: string): Promise<IOperationResult<EntityListResponse_GraphCalendarEventClientReceive>> {
    const params: { calendarId: string, startDateTimeUtc: string, endDateTimeUtc: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, search?: string } = { calendarId, startDateTimeUtc, endDateTimeUtc, $filter, $orderby, $top, $skip, search };
    const result = await Office365OutlookService.client.executeAsync<{ calendarId: string, startDateTimeUtc: string, endDateTimeUtc: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, search?: string }, EntityListResponse_GraphCalendarEventClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetEventsCalendarViewV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get event (V2)
   * This operation gets a specific event from a calendar. (V2)
   */
  public static async V2CalendarGetItem(table: string, id: string): Promise<IOperationResult<CalendarEventClientReceiveStringEnums>> {
    const params: { table: string, id: string } = { table, id };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string }, CalendarEventClientReceiveStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V2CalendarGetItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update event (V2)
   * This operation updates an event in a calendar. (V2)
   */
  public static async V2CalendarPatchItem(table: string, id: string, item: CalendarEventClient): Promise<IOperationResult<CalendarEventClientReceiveStringEnums>> {
    const params: { table: string, id: string, item: CalendarEventClient } = { table, id, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string, item: CalendarEventClient }, CalendarEventClientReceiveStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V2CalendarPatchItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get event (V3)
   * This operation gets a specific event from a calendar using Graph API. (V3)
   */
  public static async V3CalendarGetItem(table: string, id: string): Promise<IOperationResult<GraphCalendarEventClientReceive>> {
    const params: { table: string, id: string } = { table, id };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string }, GraphCalendarEventClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V3CalendarGetItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update event (V3)
   * This operation updates an event in a calendar.
   */
  public static async V3CalendarPatchItem(table: string, id: string, item: CalendarEventHtmlClient): Promise<IOperationResult<CalendarEventClientReceiveStringEnums>> {
    const params: { table: string, id: string, item: CalendarEventHtmlClient } = { table, id, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string, item: CalendarEventHtmlClient }, CalendarEventClientReceiveStringEnums>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V3CalendarPatchItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update event (V4)
   * This operation updates an event in a calendar using Graph API.
   */
  public static async V4CalendarPatchItem(table: string, id: string, item: GraphCalendarEventClient): Promise<IOperationResult<GraphCalendarEventClientReceive>> {
    const params: { table: string, id: string, item: GraphCalendarEventClient } = { table, id, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string, item: GraphCalendarEventClient }, GraphCalendarEventClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'V4CalendarPatchItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new event is created (V1)
   * This operation triggers a flow when a new event is created in a calendar. (V1)
   */
  public static async CalendarGetOnNewItems(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string): Promise<IOperationResult<CalendarEventList>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string } = { table, $filter, $orderby, $top, $skip, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string }, CalendarEventList>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnNewItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an event is modified (V1)
   * This operation triggers a flow when an event is modified in a calendar. (V1)
   */
  public static async CalendarGetOnUpdatedItems(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<CalendarEventList>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, CalendarEventList>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnUpdatedItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new item is created in a table
   * This operation triggers a flow when a new item is created in a table.
   */
  public static async ODataStyleGetOnNewItems(dataset: string, table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<CalendarEventList>> {
    const params: { dataset: string, table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { dataset, table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ dataset: string, table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, CalendarEventList>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ODataStyleGetOnNewItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an item is modified
   * This operation triggers a flow when an item is modified in a table.
   */
  public static async ODataStyleCalendarGetOnUpdatedItems(dataset: string, table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<CalendarEventList>> {
    const params: { dataset: string, table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { dataset, table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ dataset: string, table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, CalendarEventList>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ODataStyleCalendarGetOnUpdatedItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new event is created (V2)
   * This operation triggers a flow when a new event is created in a calendar. (V2)
   */
  public static async CalendarGetOnNewItemsV2(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string): Promise<IOperationResult<CalendarEventListClientReceive>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string } = { table, $filter, $orderby, $top, $skip, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string }, CalendarEventListClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnNewItemsV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When a new event is created (V3)
   * This operation triggers a flow when a new event is created in a calendar. (V3)
   */
  public static async CalendarGetOnNewItemsV3(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string): Promise<IOperationResult<GraphCalendarEventListClientReceive>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string } = { table, $filter, $orderby, $top, $skip, x_ms_operation_context };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number, x_ms_operation_context?: string }, GraphCalendarEventListClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnNewItemsV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an event is modified (V2)
   * This operation triggers a flow when an event is modified in a calendar. (V2)
   */
  public static async CalendarGetOnUpdatedItemsV2(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<CalendarEventListClientReceive>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, CalendarEventListClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnUpdatedItemsV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an event is modified (V3)
   * This operation triggers a flow when an event is modified in a calendar. (V3)
   */
  public static async CalendarGetOnUpdatedItemsV3(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<GraphCalendarEventListClientReceive>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, GraphCalendarEventListClientReceive>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnUpdatedItemsV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an event is added, updated or deleted
   * This operation triggers a flow when an event is added, updated or deleted in a calendar.
   */
  public static async CalendarGetOnChangedItems(table: string, incomingDays?: number, pastDays?: number): Promise<IOperationResult<CalendarEventListWithActionType>> {
    const params: { table: string, incomingDays?: number, pastDays?: number } = { table, incomingDays, pastDays };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, incomingDays?: number, pastDays?: number }, CalendarEventListWithActionType>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnChangedItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an event is added, updated or deleted (V2)
   * This operation triggers a flow when an event is added, updated or deleted in a calendar. (V2)
   */
  public static async CalendarGetOnChangedItemsV2(table: string, incomingDays?: number, pastDays?: number): Promise<IOperationResult<GraphCalendarEventListWithActionType>> {
    const params: { table: string, incomingDays?: number, pastDays?: number } = { table, incomingDays, pastDays };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, incomingDays?: number, pastDays?: number }, GraphCalendarEventListWithActionType>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnChangedItemsV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * When an event is added, updated or deleted (V3)
   * This operation triggers a flow when an event is added, updated or deleted in a calendar. (V3) This is not available in Mooncake.
   */
  public static async CalendarGetOnChangedItemsV3(table: string, incomingDays?: number, pastDays?: number): Promise<IOperationResult<GraphCalendarEventListWithActionType>> {
    const params: { table: string, incomingDays?: number, pastDays?: number } = { table, incomingDays, pastDays };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, incomingDays?: number, pastDays?: number }, GraphCalendarEventListWithActionType>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetOnChangedItemsV3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get contact folders
   * This operation lists available contacts folders.
   */
  public static async ContactGetTables(): Promise<IOperationResult<EntityListResponse_Table>> {
    const result = await Office365OutlookService.client.executeAsync<void, EntityListResponse_Table>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactGetTables',
        },
      });
    return result;
  }

  /**
   * Get contact folders (V2)
   * This operation lists available contacts folders using Graph API
   */
  public static async ContactGetTablesV2(): Promise<IOperationResult<EntityListResponse_GraphContactFolder>> {
    const result = await Office365OutlookService.client.executeAsync<void, EntityListResponse_GraphContactFolder>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactGetTablesV2',
        },
      });
    return result;
  }

  /**
   * Get contacts
   * This operation gets contacts from a contacts folder.
   */
  public static async ContactGetItems(table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<EntityListResponse_ContactResponse>> {
    const params: { table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { table, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, EntityListResponse_ContactResponse>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactGetItems',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create contact
   * This operation creates a new contact in a contacts folder.
   */
  public static async ContactPostItem(table: string, item: Contact): Promise<IOperationResult<ContactResponse>> {
    const params: { table: string, item: Contact } = { table, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, item: Contact }, ContactResponse>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactPostItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get contact
   * This operation gets a specific contact from a contacts folder.
   */
  public static async ContactGetItem(table: string, id: string): Promise<IOperationResult<ContactResponse>> {
    const params: { table: string, id: string } = { table, id };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string }, ContactResponse>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactGetItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete contact
   * This operation deletes a contact from a contacts folder.
   */
  public static async ContactDeleteItem(table: string, id: string): Promise<IOperationResult<void>> {
    const params: { table: string, id: string } = { table, id };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactDeleteItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update contact
   * This operation updates a contact in a contacts folder.
   */
  public static async ContactPatchItem(table: string, id: string, item: Contact): Promise<IOperationResult<ContactResponse>> {
    const params: { table: string, id: string, item: Contact } = { table, id, item };
    const result = await Office365OutlookService.client.executeAsync<{ table: string, id: string, item: Contact }, ContactResponse>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactPatchItem',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get datasets
   * This operation gets Contacts or Calendars
   */
  public static async GetDataSets(): Promise<IOperationResult<DataSetsList>> {
    const result = await Office365OutlookService.client.executeAsync<void, DataSetsList>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetDataSets',
        },
      });
    return result;
  }

  /**
   * Export email
   * Export the content of the email.
   */
  public static async ExportEmail(messageId: string): Promise<IOperationResult<string>> {
    const params: { messageId: string } = { messageId };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string }, string>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ExportEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Export email (V2)
   * Export the content of the email in the EML file format.
   */
  public static async ExportEmail_V2(messageId: string, mailboxAddress?: string): Promise<IOperationResult<string>> {
    const params: { messageId: string, mailboxAddress?: string } = { messageId, mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, mailboxAddress?: string }, string>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ExportEmail_V2',
          parameters: params
        },
      });
    return result;
  }

  

  /**
   * Mark as read or unread (V2)
   * This operation marks an email as read/unread.
   */
  public static async MarkAsRead_V2(messageId: string, mailboxAddress?: string, body?: Record<string, unknown>): Promise<IOperationResult<void>> {
    const params: { messageId: string, mailboxAddress?: string, body?: Record<string, unknown> } = { messageId, mailboxAddress, body };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, mailboxAddress?: string, body?: Record<string, unknown> }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'MarkAsRead_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Mark as read or unread (V3)
   * This operation marks an email as read/unread.
   */
  public static async MarkAsRead_V3(messageId: string, mailboxAddress?: string, body?: Record<string, unknown>): Promise<IOperationResult<void>> {
    const params: { messageId: string, mailboxAddress?: string, body?: Record<string, unknown> } = { messageId, mailboxAddress, body };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, mailboxAddress?: string, body?: Record<string, unknown> }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'MarkAsRead_V3',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete email (V2)
   * This operation deletes an email by id.
   */
  public static async DeleteEmail_V2(messageId: string, mailboxAddress?: string): Promise<IOperationResult<void>> {
    const params: { messageId: string, mailboxAddress?: string } = { messageId, mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, mailboxAddress?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'DeleteEmail_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get Attachment (V2)
   * This operation gets an email attachment by id.
   */
  public static async GetAttachment_V2(messageId: string, attachmentId: string, mailboxAddress?: string, extractSensitivityLabel?: boolean, fetchSensitivityLabelMetadata?: boolean): Promise<IOperationResult<Record<string, unknown>>> {
    const params: { messageId: string, attachmentId: string, mailboxAddress?: string, extractSensitivityLabel?: boolean, fetchSensitivityLabelMetadata?: boolean } = { messageId, attachmentId, mailboxAddress, extractSensitivityLabel, fetchSensitivityLabelMetadata };
    const result = await Office365OutlookService.client.executeAsync<{ messageId: string, attachmentId: string, mailboxAddress?: string, extractSensitivityLabel?: boolean, fetchSensitivityLabelMetadata?: boolean }, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetAttachment_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Respond to an event invite
   * Respond to an event invite.
   */
  public static async RespondToEvent(event_id: string, response: string, body?: ResponseToEventInvite): Promise<IOperationResult<void>> {
    const params: { event_id: string, response: string, body?: ResponseToEventInvite } = { event_id, response, body };
    const result = await Office365OutlookService.client.executeAsync<{ event_id: string, response: string, body?: ResponseToEventInvite }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'RespondToEvent',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Respond to an event invite (V2)
   * Respond to an event invite.
   */
  public static async RespondToEvent_V2(event_id: string, response: string, body?: ResponseToEventInvite): Promise<IOperationResult<void>> {
    const params: { event_id: string, response: string, body?: ResponseToEventInvite } = { event_id, response, body };
    const result = await Office365OutlookService.client.executeAsync<{ event_id: string, response: string, body?: ResponseToEventInvite }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'RespondToEvent_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Forward an email
   * Forward an email.
   */
  public static async ForwardEmail(message_id: string, body: DirectForwardMessage): Promise<IOperationResult<void>> {
    const params: { message_id: string, body: DirectForwardMessage } = { message_id, body };
    const result = await Office365OutlookService.client.executeAsync<{ message_id: string, body: DirectForwardMessage }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ForwardEmail',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Forward an email (V2)
   * Forward an email.
   */
  public static async ForwardEmail_V2(message_id: string, body: DirectForwardMessage, mailboxAddress?: string): Promise<IOperationResult<void>> {
    const params: { message_id: string, body: DirectForwardMessage, mailboxAddress?: string } = { message_id, body, mailboxAddress };
    const result = await Office365OutlookService.client.executeAsync<{ message_id: string, body: DirectForwardMessage, mailboxAddress?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ForwardEmail_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get room lists
   * Get all the room lists defined in the user's tenant
   */
  public static async GetRoomLists(): Promise<IOperationResult<Record<string, unknown>>> {
    const result = await Office365OutlookService.client.executeAsync<void, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetRoomLists',
        },
      });
    return result;
  }

  /**
   * Get room lists (V2)
   * Get all the room lists defined in the user's tenant
   */
  public static async GetRoomLists_V2(): Promise<IOperationResult<Record<string, unknown>>> {
    const result = await Office365OutlookService.client.executeAsync<void, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetRoomLists_V2',
        },
      });
    return result;
  }

  /**
   * Get rooms
   * Get all the meeting rooms defined in the user's tenant
   */
  public static async GetRooms(): Promise<IOperationResult<Record<string, unknown>>> {
    const result = await Office365OutlookService.client.executeAsync<void, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetRooms',
        },
      });
    return result;
  }

  /**
   * Get rooms (V2)
   * Get all the meeting rooms defined in the user's tenant
   */
  public static async GetRooms_V2(): Promise<IOperationResult<Record<string, unknown>>> {
    const result = await Office365OutlookService.client.executeAsync<void, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetRooms_V2',
        },
      });
    return result;
  }

  /**
   * Get rooms in room list
   * Get the meeting rooms in a specific room list
   */
  public static async GetRoomsInRoomList(room_list: string): Promise<IOperationResult<Record<string, unknown>>> {
    const params: { room_list: string } = { room_list };
    const result = await Office365OutlookService.client.executeAsync<{ room_list: string }, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetRoomsInRoomList',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get rooms in room list (V2)
   * Get the meeting rooms in a specific room list
   */
  public static async GetRoomsInRoomList_V2(room_list: string): Promise<IOperationResult<Record<string, unknown>>> {
    const params: { room_list: string } = { room_list };
    const result = await Office365OutlookService.client.executeAsync<{ room_list: string }, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetRoomsInRoomList_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Find meeting times
   * Find meeting time suggestions based on organizer, attendee availability, and time or location constraints
   */
  public static async FindMeetingTimes(body: Record<string, unknown>): Promise<IOperationResult<Record<string, unknown>>> {
    const params: { body: Record<string, unknown> } = { body };
    const result = await Office365OutlookService.client.executeAsync<{ body: Record<string, unknown> }, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'FindMeetingTimes',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Find meeting times (V2)
   * Find meeting time suggestions based on organizer, attendee availability, and time or location constraints
   */
  public static async FindMeetingTimes_V2(body: Record<string, unknown>): Promise<IOperationResult<Record<string, unknown>>> {
    const params: { body: Record<string, unknown> } = { body };
    const result = await Office365OutlookService.client.executeAsync<{ body: Record<string, unknown> }, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'FindMeetingTimes_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Set up automatic replies (V2)
   * Set the automatic replies setting for your mailbox.
   */
  public static async SetAutomaticRepliesSetting_V2(body: Record<string, unknown>): Promise<IOperationResult<Record<string, unknown>>> {
    const params: { body: Record<string, unknown> } = { body };
    const result = await Office365OutlookService.client.executeAsync<{ body: Record<string, unknown> }, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'SetAutomaticRepliesSetting_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get mail tips for a mailbox (V2)
   * Get mail tips for a mailbox such as automatic replies / OOF message or if the mailbox is full. This is not available in GccHigh and Mooncake.
   */
  public static async GetMailTips_V2(body: Record<string, unknown>): Promise<IOperationResult<{ value: MailTipsClientReceive_V2[] }>> {
    const params: { body: Record<string, unknown> } = { body };
    const result = await Office365OutlookService.client.executeAsync<{ body: Record<string, unknown> }, { value: MailTipsClientReceive_V2[] }>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'GetMailTips_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get calendars (V2)
   * This operation lists available calendars.
   */
  public static async CalendarGetTables_V2(skip?: number, top?: number, orderBy?: string): Promise<IOperationResult<Record<string, unknown>>> {
    const params: { skip?: number, top?: number, orderBy?: string } = { skip, top, orderBy };
    const result = await Office365OutlookService.client.executeAsync<{ skip?: number, top?: number, orderBy?: string }, Record<string, unknown>>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarGetTables_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete event (V2)
   * This operation deletes an event in a calendar.
   */
  public static async CalendarDeleteItem_V2(calendar: string, event: string): Promise<IOperationResult<void>> {
    const params: { calendar: string, event: string } = { calendar, event };
    const result = await Office365OutlookService.client.executeAsync<{ calendar: string, event: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'CalendarDeleteItem_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get contact (V2)
   * This operation gets a specific contact from a contacts folder.
   */
  public static async ContactGetItem_V2(folder: string, id: string): Promise<IOperationResult<ContactResponse_V2>> {
    const params: { folder: string, id: string } = { folder, id };
    const result = await Office365OutlookService.client.executeAsync<{ folder: string, id: string }, ContactResponse_V2>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactGetItem_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Delete contact (V2)
   * This operation deletes a contact from a contacts folder.
   */
  public static async ContactDeleteItem_V2(folder: string, id: string): Promise<IOperationResult<void>> {
    const params: { folder: string, id: string } = { folder, id };
    const result = await Office365OutlookService.client.executeAsync<{ folder: string, id: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactDeleteItem_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update contact (V2)
   * This operation updates a contact in a contacts folder.
   */
  public static async ContactPatchItem_V2(folder: string, id: string, item: Contact_V2): Promise<IOperationResult<ContactResponse_V2>> {
    const params: { folder: string, id: string, item: Contact_V2 } = { folder, id, item };
    const result = await Office365OutlookService.client.executeAsync<{ folder: string, id: string, item: Contact_V2 }, ContactResponse_V2>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactPatchItem_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Get contacts (V2)
   * This operation gets contacts from a contacts folder.
   */
  public static async ContactGetItems_V2(folder: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number): Promise<IOperationResult<EntityListResponse_ContactResponse_V2>> {
    const params: { folder: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number } = { folder, $filter, $orderby, $top, $skip };
    const result = await Office365OutlookService.client.executeAsync<{ folder: string, $filter?: string, $orderby?: string, $top?: number, $skip?: number }, EntityListResponse_ContactResponse_V2>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactGetItems_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Create contact (V2)
   * This operation creates a new contact in a contacts folder.
   */
  public static async ContactPostItem_V2(folder: string, item: Contact_V2): Promise<IOperationResult<void>> {
    const params: { folder: string, item: Contact_V2 } = { folder, item };
    const result = await Office365OutlookService.client.executeAsync<{ folder: string, item: Contact_V2 }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ContactPostItem_V2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Update my contact's photo
   * Updates the photo of the specified contact of the current user. The size of the photo must be less than 4 MB.
   */
  public static async UpdateMyContactPhoto(folder: string, id: string, body: string, Content_Type?: string): Promise<IOperationResult<void>> {
    const params: { folder: string, id: string, body: string, Content_Type?: string } = { folder, id, body, Content_Type };
    const result = await Office365OutlookService.client.executeAsync<{ folder: string, id: string, body: string, Content_Type?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'UpdateMyContactPhoto',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Send an HTTP request
   * Construct a Microsoft Graph REST API request to invoke. These segments are supported: 1st segement: /me, /users/<userId> 2nd segment: messages, mailFolders, events, calendar, calendars, outlook, inferenceClassification. Learn more: https://docs.microsoft.com/en-us/graph/use-the-api.
   */
  public static async HttpRequest(Uri: string, Method: string, Body?: string, ContentType?: string, CustomHeader1?: string, CustomHeader2?: string, CustomHeader3?: string, CustomHeader4?: string, CustomHeader5?: string): Promise<IOperationResult<ObjectWithoutType>> {
    const params: { Uri: string, Method: string, Body?: string, ContentType?: string, CustomHeader1?: string, CustomHeader2?: string, CustomHeader3?: string, CustomHeader4?: string, CustomHeader5?: string } = { Uri, Method, Body, ContentType, CustomHeader1, CustomHeader2, CustomHeader3, CustomHeader4, CustomHeader5 };
    const result = await Office365OutlookService.client.executeAsync<{ Uri: string, Method: string, Body?: string, ContentType?: string, CustomHeader1?: string, CustomHeader2?: string, CustomHeader3?: string, CustomHeader4?: string, CustomHeader5?: string }, ObjectWithoutType>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'HttpRequest',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Email Management MCP Server
   * This MCP server manages email messages from your Office 365 account
   */
  public static async mcp_EmailsManagement(queryRequest?: MCPQueryRequest, sessionId?: string): Promise<IOperationResult<MCPQueryResponse>> {
    const params: { queryRequest?: MCPQueryRequest, sessionId?: string } = { queryRequest, sessionId };
    const result = await Office365OutlookService.client.executeAsync<{ queryRequest?: MCPQueryRequest, sessionId?: string }, MCPQueryResponse>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'mcp_EmailsManagement',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Meeting Management MCP Server
   * This MCP server manages events, calendars and meetings
   */
  public static async mcp_MeetingManagement(queryRequest?: MCPQueryRequest, sessionId?: string): Promise<IOperationResult<MCPQueryResponse>> {
    const params: { queryRequest?: MCPQueryRequest, sessionId?: string } = { queryRequest, sessionId };
    const result = await Office365OutlookService.client.executeAsync<{ queryRequest?: MCPQueryRequest, sessionId?: string }, MCPQueryResponse>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'mcp_MeetingManagement',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Contact Management MCP Server
   * This MCP server manages contacts
   */
  public static async mcp_ContactsManagement(queryRequest?: MCPQueryRequest, sessionId?: string): Promise<IOperationResult<MCPQueryResponse>> {
    const params: { queryRequest?: MCPQueryRequest, sessionId?: string } = { queryRequest, sessionId };
    const result = await Office365OutlookService.client.executeAsync<{ queryRequest?: MCPQueryRequest, sessionId?: string }, MCPQueryResponse>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'mcp_ContactsManagement',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Receives response from user
   * This operation gets a response from the user.
   */
  public static async ReceiveResponseGet(state: string, sig?: string, showConfirm?: boolean): Promise<IOperationResult<string>> {
    const params: { state: string, sig?: string, showConfirm?: boolean } = { state, sig, showConfirm };
    const result = await Office365OutlookService.client.executeAsync<{ state: string, sig?: string, showConfirm?: boolean }, string>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReceiveResponseGet',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Receives response from user
   * This operation gets a response from the user.
   */
  public static async ReceiveResponsePost(state: string, sig?: string, fromConfirm?: boolean): Promise<IOperationResult<string>> {
    const params: { state: string, sig?: string, fromConfirm?: boolean } = { state, sig, fromConfirm };
    const result = await Office365OutlookService.client.executeAsync<{ state: string, sig?: string, fromConfirm?: boolean }, string>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReceiveResponsePost',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Receive mail
   * This operation validates the subscription request.
   */
  public static async ReceiveMailFromSubscription(state: string, subscriptionPayload: SubscriptionPayload_OutlookReceiveMessage, validationtoken?: string): Promise<IOperationResult<void>> {
    const params: { state: string, subscriptionPayload: SubscriptionPayload_OutlookReceiveMessage, validationtoken?: string } = { state, subscriptionPayload, validationtoken };
    const result = await Office365OutlookService.client.executeAsync<{ state: string, subscriptionPayload: SubscriptionPayload_OutlookReceiveMessage, validationtoken?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReceiveMailFromSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Receive mail (V2)
   * This operation validates the subscription request.
   */
  public static async ReceiveMailFromSubscriptionV2(state: string, subscriptionPayload: SubscriptionPayload_OutlookReceiveMessage, subscribedConnectionId: string, validationtoken?: string): Promise<IOperationResult<void>> {
    const params: { state: string, subscriptionPayload: SubscriptionPayload_OutlookReceiveMessage, subscribedConnectionId: string, validationtoken?: string } = { state, subscriptionPayload, subscribedConnectionId, validationtoken };
    const result = await Office365OutlookService.client.executeAsync<{ state: string, subscriptionPayload: SubscriptionPayload_OutlookReceiveMessage, subscribedConnectionId: string, validationtoken?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReceiveMailFromSubscriptionV2',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Receive event
   * This operation validates the subscription request.
   */
  public static async ReceiveEventFromSubscription(state: string, subscriptionPayload: SubscriptionPayload_SubscriptionEvent, validationtoken?: string): Promise<IOperationResult<void>> {
    const params: { state: string, subscriptionPayload: SubscriptionPayload_SubscriptionEvent, validationtoken?: string } = { state, subscriptionPayload, validationtoken };
    const result = await Office365OutlookService.client.executeAsync<{ state: string, subscriptionPayload: SubscriptionPayload_SubscriptionEvent, validationtoken?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReceiveEventFromSubscription',
          parameters: params
        },
      });
    return result;
  }

  /**
   * Receive event (V2)
   * This operation validates the subscription request.
   */
  public static async ReceiveEventFromSubscriptionV2(state: string, subscriptionPayload: SubscriptionPayload_SubscriptionEvent, subscribedConnectionId: string, validationtoken?: string): Promise<IOperationResult<void>> {
    const params: { state: string, subscriptionPayload: SubscriptionPayload_SubscriptionEvent, subscribedConnectionId: string, validationtoken?: string } = { state, subscriptionPayload, subscribedConnectionId, validationtoken };
    const result = await Office365OutlookService.client.executeAsync<{ state: string, subscriptionPayload: SubscriptionPayload_SubscriptionEvent, subscribedConnectionId: string, validationtoken?: string }, void>(
      {
        connectorOperation: {
          tableName: Office365OutlookService.dataSourceName,
          operationName: 'ReceiveEventFromSubscriptionV2',
          parameters: params
        },
      });
    return result;
  }
}
